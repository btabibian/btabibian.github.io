---
title: John McCarthy's legacy
categories: notes
date: 2011-10-27
img: ["http://www-formal.stanford.edu/jmc/jmcbw.jpg"]
author: "behzad_tabibian"
layout: single
comments: true
---
<div style="display:inline;float:left;margin-top:5px;margin-right:10px;margin-bottom:0px;margin-left:0px"><code><a href="http://www-formal.stanford.edu/jmc/jmcbw.jpg" imageanchor="1" rel="nofollow"><img alt="John McCarthy" border="0" height="200" src="http://www-formal.stanford.edu/jmc/jmcbw.jpg" width="142"/></a></code></div><div>qctober was a sad month for all those in computers. John McCarthy designer of LISP programmming language passed away on October 24, 2011. From <a href="http://blogs.msdn.com/b/shawnhar/" rel="nofollow" target="_blank">Shawn Hargreaves blog</a> my attention was drawn to the paper <a href="http://www-formal.stanford.edu/jmc/recursive/recursive.html" rel="nofollow" target="_blank">Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I</a> and specifically the part describing memory management. </div><div><br/></div><div>For those of you familiar with garbage collection mechanisms in languages such as C# and Java you will probably find this description interesting given that it was proposed for computers with limited resources at the time it was designed(single digit kilobytes of memory). </div>


<!--break-->

<div class="sites-codeblock sites-codesnippet-block"><code>At any given time only a part of the memory reserved for list structures will actually be in use for storing S-expressions. The remaining registers (in our system the number, initially, is approximately 15,000) are arranged in a single list called the</code><code> </code><em><code>free-storage list</code></em><code>. A certain register, FREE, in the program contains the location of the first register in this list. When a word is required to form some additional list structure, the first word on the</code><code> </code><em><code>free-storage list</code></em><code> </code><code>is taken and the number in register FREE is changed to become the location of the second word on the free-storage list. No provision need be made for the user to program the return of registers to the free-storage list.</code><p><code>This return takes place automatically, approximately as follows (it is necessary to give a simplified description of this process in this report): There is a fixed set of base registers in the program which contains the locations of list structures that are accessible to the program. Of course, because list structures branch, an arbitrary number of registers may be involved. Each register that is accessible to the program is accessible because it can be reached from one or more of the base registers by a chain of</code><code> </code><img align="bottom" alt="$car$" border="0" height="16" src="http://www-formal.stanford.edu/jmc/recursive/img210.png" width="31"/><code> </code><code>and</code><code> </code><img align="bottom" alt="$cdr$" border="0" height="17" src="http://www-formal.stanford.edu/jmc/recursive/img211.png" width="31"/><code> </code><code>operations. When the contents of a base register are changed, it may happen that the register to which the base register formerly pointed cannot be reached by a</code><code> </code><img align="middle" alt="$car-cdr$" border="0" height="35" src="http://www-formal.stanford.edu/jmc/recursive/img212.png" width="81"/><code> </code><code>chain from any base register. Such a register may be considered abandoned by the program because its contents can no longer be found by any possible program; hence its contents are no longer of interest, and so we would like to have it back on the free-storage list. This comes about in the following way.</code></p><p><code>Nothing happens until the program runs out of free storage. When a free register is wanted, and there is none left on the free-storage list, a reclamation</code><a href="http://www-formal.stanford.edu/jmc/recursive/footnode.html#foot357" name="tex2html8" rel="nofollow"><sup><code>8</code></sup></a><code> </code><code>cycle starts.</code></p><p><code>First, the program finds all registers accessible from the base registers and makes their signs negative. This is accomplished by starting from each of the base registers and changing the sign of every register that can be reached from it by a</code><code> </code><img align="middle" alt="$car-cdr$" border="0" height="35" src="http://www-formal.stanford.edu/jmc/recursive/img212.png" width="81"/><code> </code><code>chain. If the program encounters a register in this process which already has a negative sign, it assumes that this register has already been reached.</code></p><p><code>After all of the accessible registers have had their signs changed, the program goes through the area of memory reserved for the storage of list structures and puts all the registers whose signs were not changed in the previous step back on the free-storage list, and makes the signs of the accessible registers positive again.</code></p><p><code>This process, because it is entirely automatic, is more convenient for the programmer than a system in which he has to keep track of and erase unwanted lists. Its efficiency depends upon not coming close to exhausting the available memory with accessible lists. This is because the reclamation process requires several seconds to execute, and therefore must result in the addition of at least several thousand registers to the free-storage list if the program is not to spend most of its time in reclamation.</code><code> </code></p></div>
